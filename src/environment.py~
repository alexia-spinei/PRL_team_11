import numpy as np
import gymnasium as gym
from gymnasium import spaces
from dataclasses import dataclass
from typing import Optional, Dict, Any


@dataclass
class DamConfig:
    prices: np.ndarray
    Wmax: float = 100_000.0
    Vmax: float = 18_000.0
    W_init: float = 50_000.0
    g: float = 9.81
    rho: float = 1000.0
    h: float = 30.0
    eta_turbine: float = 0.9
    eta_pump: float = 0.8


class DamEnvGym(gym.Env):
    metadata = {"render_modes": []}

    def __init__(self, config: DamConfig):
        super().__init__()
        self.cfg = config

        # --- action & observation spaces ---
        self.action_space = spaces.Discrete(3)  # idle, sell, buy
        self.observation_space = spaces.Box(
            low=np.array([0.0, -np.inf], dtype=np.float32),
            high=np.array([1.0, np.inf], dtype=np.float32),
            dtype=np.float32,
        )

        self.reset()

    def _potential_energy_mwh(self, volume_m3: float) -> float:
        joules = self.cfg.rho * self.cfg.g * self.cfg.h * volume_m3
        return joules / 3.6e9

    def _observation(self):
        return np.array(
            [self.W_t / self.cfg.Wmax, self.cfg.prices[self.t]],
            dtype=np.float32
        )

    def reset(self, *, seed: Optional[int] = None, options: Optional[dict] = None):
        super().reset(seed=seed)
        self.t = 0
        self.W_t = self.cfg.W_init
        self.pnl = 0.0
        return self._observation(), {}

    def step(self, action: int):
        price = self.cfg.prices[self.t]

        if action == 1:      # sell
            V = min(self.cfg.Vmax, self.W_t)
        elif action == 2:    # buy
            V = min(self.cfg.Vmax, self.cfg.Wmax - self.W_t)
        else:                # idle
            V = 0.0

        E_pot = self._potential_energy_mwh(V)

        if action == 1 and V > 0:
            reward = price * (self.cfg.eta_turbine * E_pot)
            self.W_t -= V
        elif action == 2 and V > 0:
            reward = -price * (E_pot / self.cfg.eta_pump)
            self.W_t += V
        else:
            reward = 0.0

        self.pnl += reward
        self.t += 1

        terminated = self.t >= len(self.cfg.prices)
        truncated = False

        obs = self._observation() if not terminated else None
        info: Dict[str, Any] = {"pnl": self.pnl, "volume": V}

        return obs, reward, terminated, truncated, info
